# 7.25
## 1. 编写计算机视觉（CV）markdown文档
查阅资料后了解什么是计算机视觉，以及他的主要方向

计算机视觉
- 模式识别
- 图像处理
- 图像理解
---
# 7.26
## 1. 完善昨日CV.md
查阅嵌入式视觉及嵌入式AI的资料

嵌入式AI
- 嵌入式视觉
- 边缘AI处理
- 多协议与物联网集成
- 模型优化与压缩（模型剪枝、权重量化、知识蒸馏）
- 安全性和隐私保护
- 深度学习的嵌入式部署

## 2. 学习markdown文档
在B站和CSDN上了解markdown的语法

markdown常用语法
1. **目录**
  [toc]

2. **六级标题** 
  # 标题1
  ## 标题2
  ###### 标题6

3. **列表**
  1. 列表1
  - 列表2
  - [x] 待办1
  - [ ] 待办2

列表
: 自定义列表1 
: 自定义列表2

4. **文本**
  *文本*    **文本**    ***文本***
  ==文本==  ~~文本~~    ~文~^本^
  > 文本 

5. **分割线**
---

6. **下划线**
  <u> 下划线 </u>

7. **注释**
  这里有一个 注释 

8. **脚注**
  这里有一个脚注 [^1]

9. **表格**
  | 列1 | 列2
  | --- | ---
  | 值1 | 值2

10. **代码&代码块**
  `printf("code\n");`
  ```C
  if(1)
     printf("code\n);
  ```

11. **链接**
  [CSDN](https://www.csdn.net/)
  <https://www.csdn.net/>

12. **插图**
  ![图片](https://img-home.csdnimg.cn/images/20201124032511.png)

[^1]: 脚注在这里鸭~
*[注释]: 注释在这里鸭~

---
# 8.2
## 1. 继续完善CV.md
完善嵌入式AI的细节内容

## 2. 学习下载Anacoonda
- anaconda是一个方便快捷的包管理器和环境管理器，继承了相当多的工具和库，并且有良好的跨平台性。jupyter notebook 、 numpy、pandas 、tensorflow或pytorch 、opencv均可在其中找到
- 简单了解Anaconda的命令行

---
# 8.6
## 1. 学习jupyter notebook
- jupyter notebook集编写、运行、展示于一体，以网页的形式打开，可以在网页页面中“直接”编写代码和运行代码，代码的运行结果也会直接在代码块下显示。如在编程过程中需要编写说明文档，可在同一个页面中直接编写，便于作及时的说明和解释。
- 将md撰写平台迁移至jupyter noteboook

## 2. 了解ipython
- IPython是一种强化的Python解释器，提供了比默认的Python解释器更丰富的功能和增强的交互性。IPython具有许多功能，包括代码补全、语法高亮、历史记录浏览、命令自动完成、内置的帮助和文档查看器等。
- 基本功能
  1. **Tab 补全**
    - 在shell中输入表达式时，只要按下Tab键，当前命名空间中任何与输入的字符串相匹配的变量(对象或者函数等)就会被找出来
  2. **? 查看帮助**
    - ? 显示方法说明信息，不包含python代码实现的显示
    - ?? 不但显示方法说明信息，还包含python代码实现的显示
  3. **hist 查询历史**
    - hist命令之后加上-n，即hist -n也可以显示出输入的序号
    - _，__，___和_i，_ii，_iii变量保存着最后三个输出和输入对象。_n和_in(这里的n表示具体的数字)变量返回第n个输出和输入的历史命令
  4. **%pylab 调用Numpy和Matplotli**
    - %pylab命令可以使Numpy和matplotlib中的科学计算功能生效，这些功能被称为基于向量和矩阵的高效操作，它能够让我们在控制台进行交互式计算和动态绘图
  5. **%run 运行脚本**
     - 所有文件都可以通过%run命令当做Python程序来运行，输入%run 路径+python文件名称即可(相当于把整个文件加载进来，所用文件中的变量和函数均可直接使用)
  6. **%time 测量运行时间**
     - % 测试单行代码
     - %% 测试多行代码
     - time 测量单次运行时间
     - timeit 测量多次运行时间，取均值

---
# 8.7
## 1.学习python语法
- 基本语法
  1. **注释** (`#` `'''` `"""` )
 
     ```python
     # 第一注释
     '''
     第二注释
     '''
     """
     第三注释
     """
     print ("Hello, Python!")
     ```
  2. **使用缩进代表代码块**
     - 缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数
  3. **多行语句**
     - 用``\``(反斜杠)隔开，但在 ``[] ``, ``{}`` , 或 ``()`` 中的多行语句，不需要使用反斜杠
  4. **数字类型**
     - python中数字有四种类型：*整数*、*布尔型*、*浮点数*和*复数*
     - *int (整数)*, 如 1, 只有一种整数类型 int，表示为长整型，为*不可变数据类型*
       - 0b(B) 引导二进制、0o(O) 引导八进制、0x(X) 引导十六进制
     - *bool (布尔)*, 如 True
     - *float (浮点数)*, 如 1.23、3E-2，为*不可变数据类型*
       - 函数round(a+b,x)限制结果位数(保留x位小数)
     - *complex (复数)*, 如 1 + 2j、 1.1 + 2.2j
       - .real表示实部, .imag表示虚部
     - 函数`type()`查看变量对相应的数据类型
  5. 同行用 `;` 隔开可显示多条语句
 
---
# 8.8、8.9
## 1. 学习python语法
- 基本语法
  1. **字符串**
    - python字符串不区分单双引号 `'` & `"`，且可用三引号 `'''` 或 `"""`表示跨行字符串
    - 反斜杠 `\` 表示转义， `r(R)` 可阻止转义，如 `r"this is a line with \n"`中`\n`会显示，而不是表现为换行
    - 字符串可用 `+` 连接，用 `*` 重复表示，用 `in` & `not in` 判断是否为子串，用 `len()` 计算长度（包括空格）
    - 字符串(从左往右)头部索引为0，尾部索引为-1
    - 字符串切片 `str[start:end]`，其中 start（包含）是切片开始的索引，end（不包含）是切片结束的索引,遵循**左闭右开**原则。
    - 字符串的切片可以加上步长参数 step，语法格式如下：`str[start:end:step]`
    - 示例如下：
    ```python
    str = '123456789'
    print(str)                 # 输出字符串
    print(str[0:-1])           # 输出第一个到倒数第二个的所有字符
    print(str[0])              # 输出字符串第一个字符
    print(str[2:5])            # 输出从第三个开始到第六个的字符（不包含）
    print(str[2:])             # 输出从第三个开始后的所有字符
    print(str[1:5:2])          # 输出从第二个开始到第五个且每隔一个的字符（步长为2）
    print(str * 2)             # 输出字符串两次
    print(str + '你好')         # 连接字符串
    print("你好" in str)        # 判断 “你好” 是否为 str 的字串，是返回 “true”，否返回 “false”,“not in” 同理
    print('hello\nrunoob')      # 使用反斜杠(\)+n转义特殊字符
    print(r'hello\nrunoob')     # 在字符串前面添加一个 r，表示原始字符串，不会发生转义
    ```
  2. **输出函数`print()`**
    - 完整形式为`print(value, ..., sep='', end='\n', file=None)`
    - `chr()` 将输入的ASCII码转化为字符；`ord()` 将字符转化为对应的ASCII码
    - 使用 `%` 格式化输出，python3.6 之后版本可使用f-string 格式化字符串，以 `f` 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去
    - 示例如下：
      ```python
      name = 'Runoob'
      'Hello %s' % name # 'Hello Runoob'
      
      name = 'Runoob'
      f'Hello {name}'  # 替换变量 'Hello Runoob'
      f'{1+2}'         # 使用表达式 '3'

      w = {'name': 'Runoob', 'url': 'www.runoob.com'}
      f'{w["name"]}: {w["url"]}' # 'Runoob: www.runoob.com'
      ```
    - python附带大量字符串内建函数，使用格式为str.name(value,...,...)
 
---
# 8.12 8.13 8.23
## 1.python语法
- 基本语法
  1. **前言**
    - 序列是Python中最基本的数据结构。序列中的每个值都有对应的位置值，称之为索引，第一个索引是0，第二个索引是1，依此类推。Python有6个序列的内置类型，但最常见的是列表和元组。列表都可以进行的操作包括***索引、切片、加、乘、检查成员***。此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法
  2. **列表**
    - 列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。列表的数据项不需要具有相同的类型，而且创建一个列表，只要把逗号分隔的不同的数据项并使用方括号括起来即可
    - 列表的索引和切片与字符串相同，`+` `*` `in` `len()` `+=`等运算与字符串相同，以及列表的嵌套（即列表的元素仍是列表）
      
      ```python
      a = ['a', 'b', 'c']
      n = [1, 2, 3]
      x = [a, n]
      x    # [['a', 'b', 'c'], [1, 2, 3]]
      x[0]    # ['a', 'b', 'c']
      x[0][1]    # 'b'
      ```
    - 列表包括以下函数
      - `len(list)`(求列表元素个数)
      - `max(list)`(返回列表元素最大值)
      - `min(list)` (返回列表元素最小值)
      - `list(seq)`(将元组转换成列表)
    - 列表还包括以下方法
      - `list.append(obj)`(将指定元素添加到列表尾部)
      - `list.count(obj)`(计算指定元素出现次数)
      - `list.extend(seq)`(将序列连接至列表尾部)
      - `list.index(obj)`(找出该元素第一次出现的索引位置)
      - `list.insert(index,obj)`(在指定位置插入指定元素)
      - `list.reverse()`(列表反向)
      - `list.clear()`(清空)
      - `list.copy()`(复制)
      - ......
    - 列表还可使用`del list[index]`语句来删除指定元素
    - 列表比较需要引入`operator`模块的`eq`方法，即`operqtor.eq(list1, list2)`
  3. **元组**
    - 与列表类似，元组的各元素间用逗号隔开，所有元素位于小括号`()`内，**也可不使用括号而直接用逗号`,`分割各元素**，注意如果元组内只有一个元素，该元素后仍要使用逗号(否则括号将被当作运算符)
    - 元组仍能进行索引、切片、加、乘等操作
    - 元组的元素无法被修改和删除，修改和删除的操作仅针对元组整体
    - 元组包括以下函数
      - `len(tuple)`
      - `max(tuple)`
      - `min(tuple)`
      - `tuple(iterable)`
  4. **字典**
    - 整个字典被包括在花括号`{}`下，字典的元素由键值对组成，键值对内部由冒号隔开`:`，对与对之间由逗号`,`隔开，其中键必须是唯一的，且只能取不可变数据类型(如果使用两个一样的键，第二个键值会被记住)，而值是不唯一的，且可取任何数据类型
    - 字典的更改类似C语言中数组的更改，不同的是数组的下标变成字典的键
    - 使用`del()`方法删除字典元素和字典整体
    - 内置函数
      - `len(dict)`
      - `str(dict)`(输出字典，以打印的字符串形式表示)
      - `type(variable)`(返回输入的变量类型)
    - 内置方法
      - `dict.copy()`
      - `dict.clear()`
      - `dict.fromkeys(seq[, value])`(创建一个新字典，以序列seq中元素做字典的键，value为字典所有键对应的初始值)
      - `dict.get(key, default=None)` `dict.setdefault(key, default=None)`(后者与前者区别在于如果查找的键不在字典里，后者会生成该键并将值设为None)
      - `key in dict`
      - `dict.items()` `dict.keys()` `dict.values()`(返回视图对象，不是列表，不支持索引和更改，可以使用`list()`来转换为列表)
      - `dict.update(dict2)`(把字典参数dict2的key/value(键值对)更新到字典dict里)(狗尾续貂doge)
      - `dict.pop(key[,default])`(删除key所对应的值，返回被删除的值，如果key不存在且默认值default没有指定，则触发KeyError异常)
      - `dict.popitem()`(返回并删除字典中的最后一对键值,即**LIFO**规则)
    - ***补充知识 ———— 赋值与复制***
      1. 直接赋值
        - `a = b`(实际是对象的别名)
      2. 浅复制(copy)
        - ```python
          a = {1: [1,2,3]}
          b = a.copy() #b = {1: [1, 2, 3]}
          
          a[1].append(4) 
          a[1].remove(1) #a = {1: [2, 3, 4]} b = {1: [2, 3, 4]}

          a.update({2: [5]}) #a = {2: [5]} b = {1: [2, 3, 4]}
          ```
          (拷贝父对象，不会拷贝对象的内部的子对象)
      3. 深复制(deepcopy)
        - ```python
          a = {1: [1,2,3]}
          import copy
          c = copy.deepcopy(a) #c = {1: [1,2,3]}

          a[1].append(4) #a = {1: [1, 2, 3, 4]}, c = {1: [1, 2, 3]}
          ```
          (引入copy模块的deepcopy方法，完全拷贝了父对象及其子对象)
  5. **集合**
    - 集合是一个元素无序不重复的序列，使用大括号`{}`创建集合，元素之间用逗号`,`分隔，或者也可以使用`set()`函数创建集合(注意创建一个空集合必须用`set()`而不是`{}`，因为`{}`是用来创建一个空字典)
    - 集合间运算
      1. 差运算 `-`
      2. 并运算 `|`
      3. 交运算 `&`
      4. 对称差运算 `^`
    - 方法
      - `set.add(elem)` `set.update(elem\set)`
      - `set.copy()`
      - `set.clear()`
      - `set.remove()` `set.discard()` 
      - `set.disjoint(set)`(是否没有交集)
      - `set.issubset(set)`(前者是否是后者的子集)
      - `set.issuperset(set)`(前者是否是后者的超集)
      - `set.union(set1, set2, ……)`(返回所有集合的并集)
      - `set.difference(set1, set2, ……)` `set.difference_update(set1, set2, ……)`(前者返回一个移除相同元素的集合，后者在原集合上直接删除元素，无返回值)
      - `set.intersection(set1, set2, ……)` `set.intersection_update(set1, set2, ……)`(前者返回交集，后者把原集合转换成交集)
      - `set.sysmmetric_difference()` `set.symmetric_difference_update()`(前者返回对称差集，后者把原集合转化成对称差集)
     
---
# 8.24